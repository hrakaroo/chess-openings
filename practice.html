<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Openings - Practice Openings</title>

    <!-- Chessboard.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 40px;
            margin: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: #667eea;
            text-decoration: none;
            font-size: 14px;
            font-weight: 500;
        }

        .back-link:hover {
            color: #764ba2;
            text-decoration: underline;
        }

        h1 {
            color: #2c3e50;
            margin: 0;
            font-size: 32px;
        }

        button {
            padding: 10px 20px;
            font-size: 14px;
            cursor: pointer;
            background-color: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            margin: 5px;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #764ba2;
        }

        button:disabled {
            background-color: #ddd;
            color: #999;
            cursor: not-allowed;
        }

        .graph-container {
            border: 1px solid #e0e0e0;
            display: inline-block;
            background-color: #fafafa;
            border-radius: 4px;
        }

        #loadedFileLabel {
            margin-top: 10px;
            font-size: 12px;
            color: #666;
            font-style: italic;
        }

        .board-readonly {
            opacity: 0.9;
        }

        #resetBtn {
            background-color: #e74c3c;
            color: white;
        }

        #resetBtn:hover {
            background-color: #c0392b;
        }

        #playAsSelect {
            padding: 8px 12px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: white;
            cursor: pointer;
        }

        #playAsSelect:focus {
            outline: none;
            border-color: #667eea;
        }

        #loadBtn {
            background-color: #3498db;
        }

        #loadBtn:hover {
            background-color: #2980b9;
        }

        #fitViewBtn {
            background-color: #95a5a6;
        }

        #fitViewBtn:hover {
            background-color: #7f8c8d;
        }

        #evaluationLabel {
            display: none;
            padding: 12px 20px;
            background-color: #E53935;
            color: white;
            border-radius: 4px;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            margin-top: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* Chess.com style board colors */
        .board-b72b1 .white-1e1d7 {
            background-color: #eeeed2;  /* Cream/beige light squares */
        }

        .board-b72b1 .black-3c85d {
            background-color: #769656;  /* Green dark squares */
        }

        /* Highlighted squares (for moves, selections, etc.) */
        .board-b72b1 .highlight-white {
            background-color: #f7f769;
        }

        .board-b72b1 .highlight-black {
            background-color: #baca44;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="index.html" class="back-link">‚Üê Back to Home</a>
            <h1>Practice Openings</h1>
        </div>

        <table style="margin: 0 auto; border-spacing: 20px;">
        <tbody><tr>
            <td style="vertical-align: top;">
                <div style="margin-bottom: 10px; width: 600px; display: flex; align-items: center; gap: 20px;">
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <label for="playAsSelect" style="font-weight: bold;">Play as:</label>
                        <select id="playAsSelect">
                            <option value="white" selected>White</option>
                            <option value="black">Black</option>
                        </select>
                    </div>
                    <button id="resetBtn" disabled>Reset</button>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <label for="scoreField" style="font-weight: bold;">Score:</label>
                        <input type="text" id="scoreField" value="0 / 0" readonly style="width: 80px; text-align: center; padding: 5px; border: 1px solid #ccc; border-radius: 4px; background-color: #f9f9f9;">
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <label for="remainingField" style="font-weight: bold;">Remaining:</label>
                        <input type="text" id="remainingField" value="0" readonly style="width: 50px; text-align: center; padding: 5px; border: 1px solid #ccc; border-radius: 4px; background-color: #f9f9f9;">
                    </div>
                </div>
                <div style="margin-bottom: 10px; width: 600px;">
                    <input type="text" id="annotationDisplay" readonly style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 4px; background-color: #f9f9f9; color: #333; box-sizing: border-box;">
                </div>
                <div id="board" class="board-readonly" style="width: 600px;"></div>
                <div id="evaluationLabel"></div>
            </td>
            <td style="vertical-align: top;">
                <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
                    <label for="preloadedSelect" style="font-size: 14px; color: #555;">Load:</label>
                    <select id="preloadedSelect" style="padding: 6px 10px; border-radius: 4px; border: 1px solid #ccc; font-size: 14px; min-width: 200px;">
                                <option value="">-- Select Opening --</option>
                                <option value="openings/london-10-15.txt">London 10-15</option>
                                <option value="openings/london-10-15_with_eval.txt">London 10-15 With Eval</option>
                            </select>
                    <button id="loadBtn">Custom File</button>
                    <input type="file" id="fileInput" accept=".txt" style="display: none;">
                    <div style="flex-grow: 1;"></div>
                    <button id="fitViewBtn">Fit View</button>
                </div>
                <div class="graph-container">
                    <canvas id="graphCanvas" width="567" height="600" style="cursor: default;"></canvas>
                </div>
                <div id="loadedFileLabel"></div>
            </td>
        </tr>
    </tbody></table>
    </div>

    <!-- jQuery (required by chessboard.js) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <!-- Chessboard.js -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>

    <!-- Chess.js for game logic -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <!-- Dagre for graph layout -->
    <script src="https://cdn.jsdelivr.net/npm/dagre@0.8.5/dist/dagre.min.js"></script>

    <!-- FEN utilities -->
    <script src="js/fen-utils.js"></script>

    <!-- UI Feedback -->
    <script src="js/ui-feedback.js"></script>

    <!-- Common chess logic -->
    <script src="js/chess-common.js"></script>

    <script>
        // Debug flag - can be toggled from console with: DEBUG_TRANSITIONS = true
        window.DEBUG_TRANSITIONS = false;

        // Practice mode state
        var practiceActive = false;
        var userColor = 'white';  // 'white' or 'black'
        var allPathsOriginal = [];  // Original paths from file (never modified)
        var allPaths = [];  // Shuffled paths for current practice session
        var currentPathIndex = 0;  // Which path we're currently on
        var currentStepIndex = 0;  // Where in the current path we are
        var pathsCompleted = 0;  // How many paths done correctly
        var pathsRemaining = 0;  // How many paths left to complete
        var mistakeOnCurrentPath = false;  // Track if user made mistake on current path

        // Play an error sound for incorrect moves
        function playErrorSound() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                var now = audioContext.currentTime;

                // Create a gentle "ding" sound - higher pitched but not harsh
                var osc = audioContext.createOscillator();
                var gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);

                // Use a triangle wave for a softer, bell-like tone
                osc.type = 'triangle';
                osc.frequency.value = 800;  // Higher pitch for error indication

                // Quick fade out
                gain.gain.setValueAtTime(0.15, now);  // Lower volume than move sound
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

                osc.start(now);
                osc.stop(now + 0.2);
            } catch (e) {
                console.warn('Audio playback not supported:', e);
            }
        }

        // Helper function to clear move highlights
        function clearMoveHighlights() {
            // Remove highlight classes from all squares
            $('#board .square-55d63').removeClass('highlight-white highlight-black');
        }

        // Helper function to highlight a move
        function highlightMove(fromSquare, toSquare) {
            clearMoveHighlights();

            if (fromSquare && toSquare) {
                // Determine if squares are light or dark for appropriate highlight color
                var fromSquareEl = $('#board .square-' + fromSquare);
                var toSquareEl = $('#board .square-' + toSquare);

                // Add highlight based on square color
                if (fromSquareEl.hasClass('white-1e1d7')) {
                    fromSquareEl.addClass('highlight-white');
                } else {
                    fromSquareEl.addClass('highlight-black');
                }

                if (toSquareEl.hasClass('white-1e1d7')) {
                    toSquareEl.addClass('highlight-white');
                } else {
                    toSquareEl.addClass('highlight-black');
                }
            }
        }

        // Shuffle an array using Fisher-Yates algorithm
        function shuffleArray(array) {
            var shuffled = array.slice(); // Create a copy
            for (var i = shuffled.length - 1; i > 0; i--) {
                var j = Math.floor(Math.random() * (i + 1));
                var temp = shuffled[i];
                shuffled[i] = shuffled[j];
                shuffled[j] = temp;
            }
            return shuffled;
        }

        // Find all terminal states (leaf nodes with no outgoing edges)
        function findTerminalStates() {
            var terminals = [];
            for (var i = 0; i < graphNodes.length; i++) {
                var hasOutgoing = false;
                for (var j = 0; j < graphEdges.length; j++) {
                    if (graphEdges[j].from === i) {
                        hasOutgoing = true;
                        break;
                    }
                }
                if (!hasOutgoing && graphNodes[i] !== 'start') {
                    terminals.push(graphNodes[i]);
                }
            }
            return terminals;
        }

        // DFS to find all paths from startState to targetState
        // NOTE: Paths are arrays of objects with { state, fullFEN } structure:
        //   - state: normalized FEN (for graph lookups and transposition detection)
        //   - fullFEN: complete FEN with en passant info (for loading into game object)
        // This dual storage preserves en passant move validation while maintaining graph topology
        function findPathsToState(startState, targetState) {
            var paths = [];
            var visited = new Set();
            var currentPath = [{ state: normalizeFEN(startState), fullFEN: startState }];

            function dfs(state) {
                var normalizedState = normalizeFEN(state);

                if (normalizedState === normalizeFEN(targetState)) {
                    paths.push(currentPath.slice());
                    return;
                }

                var stateIndex = stateToIndex.get(normalizedState);
                if (stateIndex === undefined) return;

                visited.add(normalizedState);

                // Find all children
                for (var i = 0; i < graphEdges.length; i++) {
                    if (graphEdges[i].from === stateIndex) {
                        var childState = graphNodes[graphEdges[i].to];
                        var childFullFEN = graphEdges[i].fullFEN || childState;

                        if (!visited.has(childState)) {
                            currentPath.push({ state: childState, fullFEN: childFullFEN });
                            dfs(childState);
                            currentPath.pop();
                        }
                    }
                }

                visited.delete(normalizedState);
            }

            dfs(startState);
            return paths;
        }

        // Find all complete paths from start to all terminals
        function findAllPaths() {
            var paths = [];
            var terminals = findTerminalStates();

            for (var i = 0; i < terminals.length; i++) {
                var terminalState = terminals[i];
                var pathsToTerminal = findPathsToState('start', terminalState);
                paths = paths.concat(pathsToTerminal);
            }

            return paths;
        }

        // Update score and remaining display
        function updateScore() {
            document.getElementById('scoreField').value = pathsCompleted + ' / ' + allPathsOriginal.length;
            document.getElementById('remainingField').value = pathsRemaining;
        }

        // Make computer move following the current path
        function makeComputerMove() {
            if (!practiceActive) {
                // Practice has been stopped
                return;
            }

            if (currentPathIndex >= allPaths.length) {
                // All paths completed - stop practice
                practiceActive = false;
                if (DEBUG_TRANSITIONS) {
                    console.log('[Practice] All paths completed!');
                }
                return;
            }

            var currentPath = allPaths[currentPathIndex];
            currentStepIndex++;

            if (currentStepIndex >= currentPath.length) {
                // Trying to go beyond path - shouldn't happen
                console.error('currentStepIndex exceeded path length');
                return;
            }

            var fromState = currentPath[currentStepIndex - 1].state;
            var fromFullFEN = currentPath[currentStepIndex - 1].fullFEN;
            var targetState = currentPath[currentStepIndex].state;
            var targetFullFEN = currentPath[currentStepIndex].fullFEN;

            if (DEBUG_TRANSITIONS) {
                console.log('[Computer Move] Path ' + (currentPathIndex + 1) + '/' + allPaths.length +
                           ', Step ' + (currentStepIndex + 1) + '/' + currentPath.length);
                console.log('  From: ' + fromState);
                console.log('  To:   ' + targetState);
            }

            // Find the edge to get the move notation
            var fromIndex = stateToIndex.get(normalizeFEN(fromState));
            var toIndex = stateToIndex.get(normalizeFEN(targetState));
            var moveSquares = null;

            if (fromIndex !== undefined && toIndex !== undefined) {
                // Find edge from fromIndex to toIndex
                for (var i = 0; i < graphEdges.length; i++) {
                    if (graphEdges[i].from === fromIndex && graphEdges[i].to === toIndex) {
                        var moveSAN = graphEdges[i].move;
                        if (moveSAN) {
                            // Use chess.js to parse the move and get from/to squares
                            // Use full FEN for accurate move parsing
                            var tempGame = new Chess(fromFullFEN === 'start' ? undefined : fromFullFEN);
                            var moveObj = tempGame.move(moveSAN);
                            if (moveObj) {
                                moveSquares = { from: moveObj.from, to: moveObj.to };
                            }
                        }
                        break;
                    }
                }
            }

            // Make the next move in the path - use full FEN to preserve en passant
            loadState(targetFullFEN, false);

            // Highlight the move
            if (moveSquares) {
                highlightMove(moveSquares.from, moveSquares.to);
            }

            // Play move sound
            playMoveSound();

            updateEvaluationLabel();

            // Check if we've reached the terminal (last position in path)
            if (currentStepIndex >= currentPath.length - 1) {
                // Computer has completed the path - only count if no mistakes
                if (!mistakeOnCurrentPath) {
                    pathsCompleted++;
                    if (DEBUG_TRANSITIONS) {
                        console.log('[Path Complete] Path ' + (currentPathIndex + 1) + ' completed successfully');
                    }
                } else {
                    if (DEBUG_TRANSITIONS) {
                        console.log('[Path Complete] Path ' + (currentPathIndex + 1) + ' completed with mistakes (not scored)');
                    }
                }

                // Decrement remaining
                pathsRemaining--;
                updateScore();

                if (DEBUG_TRANSITIONS) {
                    console.log('[Score] ' + pathsCompleted + '/' + allPathsOriginal.length + ', Remaining: ' + pathsRemaining);
                }

                // Move to next path
                currentPathIndex++;

                // Check if all paths are done
                if (currentPathIndex >= allPaths.length) {
                    // All paths completed - stop practice but stay on final state
                    practiceActive = false;
                    if (DEBUG_TRANSITIONS) {
                        console.log('[Practice] All paths completed!');
                    }
                    return;
                }

                // Move to next path after a short delay
                setTimeout(function() {
                    if (DEBUG_TRANSITIONS) {
                        console.log('[New Path] Starting path ' + (currentPathIndex + 1) + '/' + allPaths.length);
                    }
                    currentStepIndex = 0;
                    mistakeOnCurrentPath = false;  // Reset mistake flag for new path

                    // Get the starting state for the new path
                    var newPath = allPaths[currentPathIndex];
                    var startFullFEN = newPath[0].fullFEN;

                    if (startFullFEN === 'start') {
                        game.reset();
                        board.position('start');
                        currentBoardState = 'start';
                    } else {
                        loadState(startFullFEN, false);
                    }

                    clearMoveHighlights();
                    updateEvaluationLabel();
                    drawGraph();

                    // If user is black, computer makes first move
                    if (userColor === 'black') {
                        setTimeout(makeComputerMove, 500);
                    }
                }, 2000);
            }
        }

        // Prevent picking up pieces if not user's turn or wrong color
        function onDragStart(source, piece, position, orientation) {
            if (!practiceActive) return false;
            if (game.game_over()) return false;

            // Only allow moving user's color
            if ((userColor === 'white' && piece.search(/^b/) !== -1) ||
                (userColor === 'black' && piece.search(/^w/) !== -1)) {
                return false;
            }

            // Check if it's user's turn
            if ((userColor === 'white' && game.turn() === 'b') ||
                (userColor === 'black' && game.turn() === 'w')) {
                return false;
            }
        }

        // On piece drop - validate against current path
        function onDrop(source, target) {
            if (!practiceActive) return 'snapback';

            var stateBefore = currentBoardState;

            // Try to make the move
            var move = game.move({
                from: source,
                to: target,
                promotion: 'q'
            });

            if (move === null) return 'snapback';

            // Get state after move
            var stateAfter = boardToFEN();

            // Check if this move matches the next state in the current path
            var currentPath = allPaths[currentPathIndex];
            var expectedNextState = currentPath[currentStepIndex + 1].state;
            var expectedNextFullFEN = currentPath[currentStepIndex + 1].fullFEN;

            if (normalizeFEN(stateAfter) !== normalizeFEN(expectedNextState)) {
                // Wrong move - mark mistake on this path
                game.undo();
                mistakeOnCurrentPath = true;

                // Play error sound
                playErrorSound();

                if (DEBUG_TRANSITIONS) {
                    console.log('[User Move] INCORRECT - Path ' + (currentPathIndex + 1) + '/' + allPaths.length +
                               ', Step ' + (currentStepIndex + 1) + '/' + currentPath.length);
                    console.log('  From: ' + stateBefore);
                    console.log('  Attempted: ' + stateAfter);
                    console.log('  Expected:  ' + expectedNextState);
                }
                return 'snapback';
            }

            if (DEBUG_TRANSITIONS) {
                console.log('[User Move] CORRECT - Path ' + (currentPathIndex + 1) + '/' + allPaths.length +
                           ', Step ' + (currentStepIndex + 1) + '/' + currentPath.length);
                console.log('  From: ' + stateBefore);
                console.log('  To:   ' + stateAfter);
            }

            // Correct move - advance in path
            currentStepIndex++;
            // Update current board state to the full FEN to preserve en passant info
            currentBoardState = expectedNextFullFEN;

            // Highlight the user's move
            highlightMove(source, target);

            // Play move sound
            playMoveSound();

            updateEvaluationLabel();
            drawGraph();

            // Check if we've reached the end of the current path
            if (currentStepIndex >= currentPath.length - 1) {
                // Path completed - only count if no mistakes were made
                if (!mistakeOnCurrentPath) {
                    pathsCompleted++;
                    if (DEBUG_TRANSITIONS) {
                        console.log('[Path Complete] Path ' + (currentPathIndex + 1) + ' completed successfully');
                    }
                } else {
                    if (DEBUG_TRANSITIONS) {
                        console.log('[Path Complete] Path ' + (currentPathIndex + 1) + ' completed with mistakes (not scored)');
                    }
                }

                // Decrement remaining
                pathsRemaining--;
                updateScore();

                if (DEBUG_TRANSITIONS) {
                    console.log('[Score] ' + pathsCompleted + '/' + allPathsOriginal.length + ', Remaining: ' + pathsRemaining);
                }

                // Move to next path
                currentPathIndex++;

                // Check if all paths are done
                if (currentPathIndex >= allPaths.length) {
                    // All paths completed - stop practice but stay on final state
                    practiceActive = false;
                    if (DEBUG_TRANSITIONS) {
                        console.log('[Practice] All paths completed!');
                    }
                    return;
                }

                setTimeout(function() {
                    if (DEBUG_TRANSITIONS) {
                        console.log('[New Path] Starting path ' + (currentPathIndex + 1) + '/' + allPaths.length);
                    }
                    currentStepIndex = 0;
                    mistakeOnCurrentPath = false;  // Reset mistake flag for new path

                    // Get the starting state for the new path
                    var newPath = allPaths[currentPathIndex];
                    var startFullFEN = newPath[0].fullFEN;

                    if (startFullFEN === 'start') {
                        game.reset();
                        board.position('start');
                        currentBoardState = 'start';
                    } else {
                        loadState(startFullFEN, false);
                    }

                    clearMoveHighlights();
                    updateEvaluationLabel();
                    drawGraph();

                    if (userColor === 'black') {
                        setTimeout(makeComputerMove, 500);
                    }
                }, 2000);
            } else {
                // Computer makes next move
                setTimeout(makeComputerMove, 500);
            }
        }

        // Update position after piece animation
        function onSnapEnd() {
            board.position(game.fen());
        }

        // Initialize the chessboard
        var config = {
            draggable: false,
            position: 'start',
            orientation: 'white',
            pieceTheme: 'https://lichess1.org/assets/piece/staunty/{piece}.svg',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: onSnapEnd
        };

        board = Chessboard('board', config);

        // Button handlers
        document.getElementById('fitViewBtn').addEventListener('click', fitView);

        // Handle preloaded opening selection
        document.getElementById('preloadedSelect').addEventListener('change', function(event) {
            var filePath = event.target.value;
            if (filePath) {
                var hideLoading = showLoading('Loading opening: ' + filePath);
                fetch(filePath)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Failed to load file: ' + response.statusText);
                        }
                        return response.text();
                    })
                    .then(content => {
                        var filename = filePath.split('/').pop();
                        loadRoutesFromFile(content, filename);

                        // Compute all paths immediately after loading
                        allPathsOriginal = findAllPaths();

                        hideLoading();
                        showSuccess('Loaded: ' + filename + ' (' + allPathsOriginal.length + ' paths)');

                        // Auto-start practice
                        startPractice();
                    })
                    .catch(error => {
                        hideLoading();
                        showError('Load Error', 'Failed to load opening file: ' + error.message);
                        // Reset selection
                        event.target.value = '';
                    });
            }
        });

        // Load button triggers file input
        document.getElementById('loadBtn').addEventListener('click', function() {
            document.getElementById('fileInput').click();
        });

        // Handle custom file selection
        document.getElementById('fileInput').addEventListener('change', function(event) {
            var file = event.target.files[0];
            if (file) {
                var hideLoading = showLoading('Loading opening file: ' + file.name);
                var reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        loadRoutesFromFile(e.target.result, file.name);

                        // Compute all paths immediately after loading
                        allPathsOriginal = findAllPaths();

                        hideLoading();
                        showSuccess('Loaded: ' + file.name + ' (' + allPathsOriginal.length + ' paths)');

                        // Auto-start practice
                        startPractice();
                    } catch (error) {
                        hideLoading();
                        showError(
                            'Error Loading File',
                            'Failed to load the opening file: ' + error.message,
                            error.stack
                        );
                    }
                };
                reader.onerror = function() {
                    hideLoading();
                    showError(
                        'File Read Error',
                        'Failed to read the file. Please try again.'
                    );
                };
                reader.readAsText(file);
            }
            event.target.value = '';
        });

        // Start practice mode
        function startPractice() {
            userColor = document.getElementById('playAsSelect').value;

            // Check if paths are loaded
            if (allPathsOriginal.length === 0) {
                return;
            }

            if (DEBUG_TRANSITIONS) {
                console.log('='.repeat(60));
                console.log('[Practice Start] Playing as ' + userColor);
                console.log('[Practice Start] Total paths: ' + allPathsOriginal.length);
                console.log('[Practice Start] Paths shuffled for random order');

                // Optionally list all paths
                if (allPathsOriginal.length <= 20) {
                    console.log('[Practice Start] Path list:');
                    for (var i = 0; i < allPathsOriginal.length; i++) {
                        console.log('  Path ' + (i + 1) + ': ' + allPathsOriginal[i].length + ' positions');
                    }
                }
                console.log('='.repeat(60));
            }

            // Enable reset button
            document.getElementById('resetBtn').disabled = false;

            // Shuffle a copy of the paths for random order (for this practice session)
            allPaths = shuffleArray(allPathsOriginal.slice());

            // Initialize path tracking
            currentPathIndex = 0;
            currentStepIndex = 0;
            pathsCompleted = 0;
            pathsRemaining = allPathsOriginal.length;
            mistakeOnCurrentPath = false;
            updateScore();

            // Get the starting state for the first path
            var firstPath = allPaths[0];
            var startFullFEN = firstPath[0].fullFEN;

            // Reset game
            if (startFullFEN === 'start') {
                game.reset();
                currentBoardState = 'start';
            } else {
                // Load the starting FEN with full en passant info
                game.load(startFullFEN);
                currentBoardState = startFullFEN;
            }

            // Recreate board as draggable
            board.destroy();
            board = Chessboard('board', {
                draggable: true,
                position: startFullFEN === 'start' ? 'start' : startFullFEN,
                orientation: userColor,
                pieceTheme: 'https://lichess1.org/assets/piece/staunty/{piece}.svg',
                onDragStart: onDragStart,
                onDrop: onDrop,
                onSnapEnd: onSnapEnd
            });

            // Enable practice mode
            practiceActive = true;

            if (DEBUG_TRANSITIONS) {
                console.log('[New Path] Starting path 1/' + allPaths.length);
            }

            // Clear any existing highlights
            clearMoveHighlights();

            // Hide evaluation label at start
            updateEvaluationLabel();
            drawGraph();

            // If playing as black, computer makes first move
            if (userColor === 'black') {
                setTimeout(makeComputerMove, 500);
            }
        }

        // Reset button handler
        document.getElementById('resetBtn').addEventListener('click', function() {
            startPractice();
        });

        // Initialize canvas
        initCanvas();
    </script>

</body>
</html>
