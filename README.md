# Chess Opening Practice Tool

A static web application for practicing chess openings. The tool captures board state transitions as you explore different opening lines.

## Features

- **Interactive chessboard** with drag-and-drop piece movement and legal move validation
- **Automatic state tracking** - each move is captured as a transition between board states
- **Move annotations** - add notes and comments to specific moves:
  - Text input field under the buttons for adding annotations
  - Annotations are saved with transitions and displayed in tooltips
  - Hover over nodes to see both the move notation and your annotation
- **Tree graph visualization** showing all explored positions as an opening tree with:
  - Optimal graph layout using Dagre algorithm (automatically minimizes edge crossings)
  - Curved edges connecting parent and child positions
  - Color-coded nodes: light grey (white to move), dark grey (black to move), green (current position)
  - Transposition detection (positions reachable via multiple move orders show multiple edges converging)
  - Click any node to jump to that board position
  - Hover over nodes to see the move that was played (e.g., "e4", "Nf3") and annotation
  - Zoom and pan support for large opening trees
- **Undo/Redo** - navigate backward and forward through your move history with keyboard shortcuts
- **Export/Import** - save and load your opening repertoire:
  - Export to custom format v2.0 (.txt) with binary base64 encoding for compact file sizes
  - Export to standard PGN format for use in other chess software
  - Import from saved v2.0 files with annotation support
- **Keyboard shortcuts** - Ctrl+Z/Cmd+Z for undo, Ctrl+Y/Cmd+Shift+Z for redo, arrow keys for navigation
- **Turn indicator** - shows whose move it is at all times

## How to Use

### Exploring Openings

1. Open `chess-openings.html` in your web browser
2. Move pieces on the board to explore opening lines
3. The turn indicator shows whose move it is (White or Black)
4. Watch the tree graph build as you make moves
5. Click any node in the graph to jump to that position

### Adding Annotations

1. After making a move, the annotation text box will show any existing annotation for that move
2. Type your note or comment in the text box (e.g., "Main line", "Tricky trap!", "Best for White")
3. Click the **Save** button to save the annotation
4. Annotations appear in the tooltip when you hover over nodes in the graph
5. Returns and quotes are automatically stripped from annotations

**Note**: Annotations are saved with the transition between two positions, so they're associated with the move that was just made.

### Managing Routes

- **Reset Board** - return to the starting position without clearing the graph
- **Reset Board and Graph** - return to the starting position and completely clear all graph data (removes all explored positions and variations)
- **Undo** - go back to the previous position in your move history (Ctrl+Z, Cmd+Z, or Left Arrow)
- **Redo** - move forward in your history after undoing (Ctrl+Y, Ctrl+Shift+Z, Cmd+Shift+Z, or Right Arrow)
- **Export Routes** - prompts for a filename, then saves all recorded transitions to a `.txt` file (v2.0 format with binary base64 encoding)
- **Load Routes** - import a previously saved v2.0 .txt file to restore your opening tree (displays the loaded filename and version below the buttons)
- **Load Positions** - optionally load a pre-computed positions JSON file generated by `generate_positions.py` for optimal graph layout with minimal edge crossings
- **Export PGN** - exports your opening tree to standard PGN (Portable Game Notation) format with variations, compatible with chess software like Lichess, Chess.com, and ChessBase
- **Cycle Layout** - switches between 12 different graph layout algorithms to find the one with the fewest edge crossings for your specific opening tree (only used when no positions file is loaded)
- **Fit View** - automatically scales and centers the graph to show all nodes within the canvas (useful after exploring large opening trees)

**Note on Undo/Redo**: When you undo, the "future" path is immediately removed from the graph. When you redo, the path is restored. If you make a new move after undoing, the old future is permanently replaced. Positions that are reachable via other paths (transpositions) are always preserved.

**Note on PGN Export**: The PGN export creates a single game with all your variations. The main line follows the first branch at each position, and alternative moves are shown as variations in parentheses.

### Optimizing Graph Layout (Advanced)

For complex opening trees with many variations, you can use the Python script to generate optimal node positions with minimal edge crossings:

1. **Install dependencies** (one-time setup):
   ```bash
   pip install networkx pygraphviz
   ```
   Note: `pygraphviz` requires graphviz to be installed on your system:
   - macOS: `brew install graphviz`
   - Ubuntu/Debian: `sudo apt-get install graphviz graphviz-dev`
   - Windows: Download from https://graphviz.org/download/

2. **Generate positions**:
   ```bash
   python generate_positions.py your-openings.txt
   ```
   This creates `your-openings-positions.json` with optimal node positions.

3. **Try different algorithms** if you see edge crossings:
   ```bash
   python generate_positions.py your-openings.txt --algorithm dot
   python generate_positions.py your-openings.txt --algorithm neato
   python generate_positions.py your-openings.txt --algorithm fdp
   ```
   Available algorithms:
   - `dot` - hierarchical/layered (best for DAGs, minimizes crossings) - **default**
   - `neato` - spring model (force-directed)
   - `fdp` - force-directed with smart edge handling
   - `sfdp` - scalable force-directed (for large graphs)

4. **Load in browser**:
   - Open `chess-openings.html`
   - Click "Load Routes" and select your `.txt` file
   - Click "Load Positions" and select the generated `.json` file
   - The graph will use the pre-computed optimal positions

**Benefits of pre-computed positions**:
- Eliminates or minimizes edge crossings
- More powerful layout algorithms than browser-based Dagre
- Can be regenerated with different algorithms to find the best one
- Optional - tool works fine without positions files

### Navigation

- Click on any node in the tree graph to set the board to that position
- The current position is highlighted in green
- Make moves from any position to extend that branch of your opening tree
- Use **Undo** and **Redo** buttons to navigate through your move history
- Undo/Redo buttons are automatically disabled when at the beginning/end of history

### Graph Controls

- **Mouse Wheel** - zoom in/out on the tree graph (zoom range: 0.1x to 5x)
- **Click and Drag** - pan around the graph to explore large opening trees
- **Click Node** - jump to that board position (adds to history)
- **Hover Over Node** - see the move that was played to reach that position (e.g., "e4", "Nf6", "O-O")
- **Cycle Layout** - switch between different graph layout algorithms to find the one with fewest edge crossings for your opening tree (cycles through 12 combinations of Dagre's ranker and alignment options)

### Keyboard Shortcuts

- **Ctrl+Z** (Windows/Linux) or **Cmd+Z** (Mac) - Undo
- **Ctrl+Y** (Windows/Linux) or **Cmd+Shift+Z** (Mac) - Redo
- **Ctrl+Shift+Z** (Windows/Linux) - Redo (alternative)
- **Left Arrow** - Undo
- **Right Arrow** - Redo

## Board State Encoding

Each board state is encoded as a compact string for efficient storage.

### Piece Encoding (Letters A-L)

**White Pieces:**
- `A` = Pawn
- `B` = Knight
- `C` = Bishop
- `D` = Rook
- `E` = Queen
- `F` = King

**Black Pieces:**
- `G` = Pawn
- `H` = Knight
- `I` = Bishop
- `J` = Rook
- `K` = Queen
- `L` = King

### Empty Square Encoding (Digits 1-9)

Empty squares use run-length encoding:
- `8` = eight consecutive empty squares
- `3` = three consecutive empty squares
- etc.

### Turn Encoding

Each state includes whose turn it is next, appended in brackets:
- `[w]` = White to move
- `[b]` = Black to move

### Special Cases

- `start[w]` = The initial chess position with white to move (shortcut to avoid encoding the full starting state)

### Board Reading Order

The board is encoded from top to bottom (rank 8 to rank 1), left to right (a-file to h-file).

## File Format

All exported files use version 2.0 format with binary base64 encoding for compact state representation.

### Format Specification

The first line must contain the version number:
```
v2.0
```

Each board state is encoded as:
1. Converted to 64 nibbles (4 bits each): 0 for empty, 1-6 for white pieces (A-F), 7-12 for black pieces (G-L)
2. Packed into 32 bytes (2 squares per byte)
3. Base64 encoded
4. Turn indicator `[w]` or `[b]` appended in readable text

Each line is still a transition with optional annotation:
```
binary_state_before -> binary_state_after
binary_state_before -> binary_state_after: annotation text
```

Example file with binary encoding:
```
v2.0
start[w] -> SnpLdIp6enh4enh4AAAAAEAAAAABAAAADECEPEBD[b]: Main line, most popular
SnpLdIp6enh4enh4AAAAAEAAAAABAAAADECEPEBD[b] -> SnpLdIp6enh4enh4AAAAIgAAAAEAAAADECEPEBD[w]: Sicilian Defense
```

**Format Benefits**:
- **Consistent length**: Every position is exactly 44 characters (base64) + 3 characters ([w] or [b]) = 47 characters
- **Compact**: Binary encoding provides efficient storage for large opening repertoires
- **Version header**: Required version header ensures forward compatibility with future formats

**Annotation Format**:
- Annotations are added after a colon (`:`) following the transition
- Spaces before the colon are ignored during parsing
- Spaces after the colon are preserved as part of the annotation
- Returns and quotes are stripped when saving annotations

## Graph Visualization

The tree graph on the right side of the screen visualizes your opening repertoire:

- **Nodes** represent board positions (states)
  - Only the root node displays a label ("start")
  - Other nodes are unlabeled circles for a clean visualization
- **Edges** are curved lines showing legal moves between positions
- **Root node** is the starting position at the top
- **Node colors**:
  - Light grey - positions where it's white's turn
  - Dark grey - positions where it's black's turn
  - Green - the current board position
- **Transpositions**:
  - Multiple edges converging into the same node indicate transpositions (positions reachable via different move orders)
- **Layout** - uses the Dagre library with Sugiyama algorithm to automatically minimize edge crossings and create optimal hierarchical layouts
- **Interactive** - zoom with mouse wheel, pan by dragging, click nodes to navigate

## Transpositions

The tool automatically detects transpositions - positions that can be reached through different move orders. When you reach the same position via different paths, the graph merges them into a single node with multiple incoming edges. You can visually identify transpositions by seeing multiple edges converging into the same position.

This helps you identify key positions in your opening repertoire that arise from multiple variations.
