<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Opening Practice</title>

    <!-- Chessboard.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }

        .container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .board-container {
            flex-shrink: 0;
        }

        #board {
            width: 600px;
        }

        .graph-container {
            flex-grow: 1;
            background-color: white;
            border: 2px solid #333;
            border-radius: 5px;
            padding: 10px;
        }

        #graphCanvas {
            display: block;
            width: 100%;
            height: 600px;
            background-color: #ffffff;
        }

        h1 {
            text-align: center;
            margin-bottom: 20px;
        }

        /* Modern Button Styling */
        button {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 500;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            background: linear-gradient(to bottom, #4a90e2, #357abd);
            color: white;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            background: linear-gradient(to bottom, #5a9def, #4589cc);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        /* Primary action buttons */
        #newRouteBtn, #resetAllBtn {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
        }

        #newRouteBtn:hover, #resetAllBtn:hover {
            background: linear-gradient(to bottom, #ec5a4d, #d0442c);
        }

        /* Success buttons */
        #exportBtn, #exportPgnBtn, #saveAnnotationBtn {
            background: linear-gradient(to bottom, #27ae60, #229954);
        }

        #exportBtn:hover, #exportPgnBtn:hover, #saveAnnotationBtn:hover {
            background: linear-gradient(to bottom, #2ecc71, #27a65f);
        }

        /* Secondary buttons */
        #loadBtn, #fitViewBtn {
            background: linear-gradient(to bottom, #95a5a6, #7f8c8d);
        }

        #loadBtn:hover, #fitViewBtn:hover {
            background: linear-gradient(to bottom, #a5b5b6, #8f9c9d);
        }

        /* Input field styling */
        #annotationInput {
            padding: 10px;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 6px;
            transition: border-color 0.2s ease;
        }

        #annotationInput:focus {
            outline: none;
            border-color: #4a90e2;
        }

        /* Turn label styling */
        #turnLabel {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            padding: 8px 16px;
            background-color: #f8f9fa;
            border-radius: 6px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Loaded file label */
        #loadedFileLabel {
            font-size: 12px;
            color: #666;
            font-style: italic;
        }
    </style>
</head>
<body>
    <h1>Chess Opening Practice</h1>

    <table style="margin: 0 auto; border-spacing: 20px;">
        <tbody><tr>
            <td style="vertical-align: top;">
                <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; width: 600px;">
                    <div>
                        <button id="newRouteBtn">Reset Board</button>
                        <button id="resetAllBtn" style="margin-left: 10px;">Reset Board and Graph</button>
                        <span id="turnLabel" style="margin-left: 20px;">White</span>
                    </div>
                    <div>
                        <button id="undoBtn">Undo</button>
                        <button id="redoBtn" style="margin-left: 10px;">Redo</button>
                    </div>
                </div>
                <div style="margin-bottom: 10px; display: flex; align-items: center; width: 600px;">
                    <input type="text" id="annotationInput" placeholder="Add annotation for last move..." style="flex: 1;">
                    <button id="saveAnnotationBtn" style="margin-left: 10px;">Save</button>
                </div>
                <div id="board"></div>
            </td>
            <td style="vertical-align: top;">
                <div style="margin-bottom: 10px; display: flex; justify-content: space-between; align-items: flex-start;">
                    <div>
                        <button id="exportBtn" style="margin-right: 10px;">Export Routes</button>
                        <button id="loadBtn">Load Routes</button>
                        <input type="file" id="fileInput" accept=".txt" style="display: none;">
                        <button id="loadPositionsBtn" style="margin-left: 10px;">Load Positions</button>
                        <input type="file" id="positionsInput" accept=".json" style="display: none;">
                        <div id="loadedFileLabel" style="margin-top: 5px;"></div>
                    </div>
                    <div>
                        <button id="exportPgnBtn" style="margin-right: 10px;">Export PGN</button>
                        <button id="cycleLayoutBtn" style="margin-right: 10px;">Cycle Layout</button>
                        <button id="fitViewBtn">Fit View</button>
                    </div>
                </div>
                <div class="graph-container">
                    <canvas id="graphCanvas" width="567" height="600" style="cursor: default;"></canvas>
                </div>
            </td>
        </tr>
    </tbody></table>

    <!-- jQuery (required by chessboard.js) -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <!-- Chessboard.js -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>

    <!-- Chess.js for game logic -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <!-- Dagre for graph layout -->
    <script src="https://cdn.jsdelivr.net/npm/dagre@0.8.5/dist/dagre.min.js"></script>

    <script>
        // Initialize the chess game logic
        var game = new Chess();

        // Graph data structures
        var graphNodes = [];  // Array of unique states
        var graphEdges = [];  // Array of {from: stateIndex, to: stateIndex, annotation: string}
        var stateToIndex = new Map();  // Map state string to its index in graphNodes
        var currentBoardState = 'start[w]';  // Track the current board state
        var lastEdgeIndex = -1;  // Track the last edge created for annotation
        var precomputedPositions = null;  // Optional pre-computed node positions from JSON

        // History tracking for undo/redo
        var moveHistory = ['start[w]'];  // Array of states in chronological order
        var historyIndex = 0;  // Current position in history
        var isNavigatingHistory = false;  // Flag to prevent adding to history during undo/redo

        // Initialize the chessboard
        var config = {
            draggable: true,
            position: 'start',
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: onSnapEnd
        };

        var board = Chessboard('board', config);

        // Prevent picking up pieces if the game is over or if it's not that player's turn
        function onDragStart(source, piece, position, orientation) {
            if (game.game_over()) return false;

            // Only allow moving pieces that match the current turn
            if ((game.turn() === 'w' && piece.search(/^b/) !== -1) ||
                (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
                return false;
            }
        }

        // Add a node to the graph if it doesn't exist, return its index
        function addNodeToGraph(state) {
            if (!stateToIndex.has(state)) {
                var index = graphNodes.length;
                graphNodes.push(state);
                stateToIndex.set(state, index);
                return index;
            }
            return stateToIndex.get(state);
        }

        // Add an edge to the graph if it doesn't exist
        function addEdgeToGraph(fromState, toState, annotation) {
            var fromIndex = addNodeToGraph(fromState);
            var toIndex = addNodeToGraph(toState);

            // Check if edge already exists
            var existingEdgeIndex = -1;
            for (var i = 0; i < graphEdges.length; i++) {
                if (graphEdges[i].from === fromIndex && graphEdges[i].to === toIndex) {
                    existingEdgeIndex = i;
                    break;
                }
            }

            if (existingEdgeIndex === -1) {
                // Create new edge
                var newEdge = {
                    from: fromIndex,
                    to: toIndex,
                    annotation: annotation || ''
                };
                graphEdges.push(newEdge);
                lastEdgeIndex = graphEdges.length - 1;
            } else {
                // Update existing edge annotation if provided
                if (annotation) {
                    graphEdges[existingEdgeIndex].annotation = annotation;
                }
                lastEdgeIndex = existingEdgeIndex;
            }
        }

        // Add state to move history
        function addToHistory(state) {
            if (isNavigatingHistory) return;

            // Remove any future history beyond current position
            // Note: removeFutureFromGraph() was already called in undo() if we undid before adding this
            // But we still need to truncate the history array
            moveHistory = moveHistory.slice(0, historyIndex + 1);

            // Add new state
            moveHistory.push(state);
            historyIndex = moveHistory.length - 1;

            // Update button states
            updateHistoryButtons();
        }

        // Remove edges and orphaned nodes that were part of the discarded future
        function removeFutureFromGraph() {
            // Remove edges that connect consecutive states in the truncated history
            // For example, if history was [start, e4, e5, Nf3] and we're at index 1 (e4),
            // we remove edges: e4->e5 and e5->Nf3

            var edgesToRemove = [];

            // Remove edges from historyIndex to historyIndex+1, historyIndex+1 to historyIndex+2, etc.
            for (var i = historyIndex; i < moveHistory.length - 1; i++) {
                var fromState = moveHistory[i];
                var toState = moveHistory[i + 1];

                var fromIndex = stateToIndex.get(fromState);
                var toIndex = stateToIndex.get(toState);

                if (fromIndex !== undefined && toIndex !== undefined) {
                    // Find and remove this specific edge
                    for (var j = 0; j < graphEdges.length; j++) {
                        if (graphEdges[j].from === fromIndex && graphEdges[j].to === toIndex) {
                            edgesToRemove.push(j);
                            break;
                        }
                    }
                }
            }

            // Remove edges in reverse order to maintain indices
            for (var i = edgesToRemove.length - 1; i >= 0; i--) {
                graphEdges.splice(edgesToRemove[i], 1);
            }

            // Find and remove orphaned nodes (nodes with no incoming edges, except start node)
            removeOrphanedNodes();
        }

        // Remove nodes that have no incoming edges (except the start node)
        function removeOrphanedNodes() {
            var hasIncoming = new Array(graphNodes.length).fill(false);

            // Mark nodes that have incoming edges
            graphEdges.forEach(function(edge) {
                hasIncoming[edge.to] = true;
            });

            // Start node should always be kept
            var startIndex = stateToIndex.get('start[w]');
            if (startIndex !== undefined) {
                hasIncoming[startIndex] = true;
            }

            // Build new arrays without orphaned nodes
            var newGraphNodes = [];
            var oldToNewIndex = new Array(graphNodes.length).fill(-1);

            for (var i = 0; i < graphNodes.length; i++) {
                if (hasIncoming[i]) {
                    oldToNewIndex[i] = newGraphNodes.length;
                    newGraphNodes.push(graphNodes[i]);
                }
            }

            // Rebuild edges with new indices
            var newGraphEdges = [];
            graphEdges.forEach(function(edge) {
                if (oldToNewIndex[edge.from] !== -1 && oldToNewIndex[edge.to] !== -1) {
                    newGraphEdges.push({
                        from: oldToNewIndex[edge.from],
                        to: oldToNewIndex[edge.to]
                    });
                }
            });

            // Rebuild state to index map
            stateToIndex.clear();
            for (var i = 0; i < newGraphNodes.length; i++) {
                stateToIndex.set(newGraphNodes[i], i);
            }

            // Update global variables
            graphNodes = newGraphNodes;
            graphEdges = newGraphEdges;
        }

        // Update undo/redo button states
        function updateHistoryButtons() {
            var undoBtn = document.getElementById('undoBtn');
            var redoBtn = document.getElementById('redoBtn');

            undoBtn.disabled = (historyIndex <= 0);
            redoBtn.disabled = (historyIndex >= moveHistory.length - 1);

            // Update visual style for disabled buttons
            undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1.0';
            undoBtn.style.cursor = undoBtn.disabled ? 'not-allowed' : 'pointer';
            redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1.0';
            redoBtn.style.cursor = redoBtn.disabled ? 'not-allowed' : 'pointer';
        }

        // Handle piece drop
        function onDrop(source, target) {
            // Capture state before move
            var stateBefore = boardToString();

            var move = game.move({
                from: source,
                to: target,
                promotion: 'q' // Always promote to queen for simplicity
            });

            // Illegal move
            if (move === null) return 'snapback';

            // Capture state after move
            var stateAfter = boardToString();

            // Add nodes and edge to graph
            addEdgeToGraph(stateBefore, stateAfter);

            // Update current board state
            currentBoardState = stateAfter;

            // Add to history
            addToHistory(stateAfter);

            // Update annotation input to show annotation for this move
            updateAnnotationInput();

            // Redraw the graph
            drawGraph();
        }

        // Update the turn label
        function updateTurnLabel() {
            var turnLabel = document.getElementById('turnLabel');
            turnLabel.textContent = game.turn() === 'w' ? 'White' : 'Black';
        }

        // Update the board position after the piece snap animation
        function onSnapEnd() {
            board.position(game.fen());
            updateTurnLabel();
        }

        // Convert board state to compact string format
        // Encoding: White pieces = A-F (P,N,B,R,Q,K), Black pieces = G-L (P,N,B,R,Q,K)
        // Empty squares use run-length encoding with digits 1-9
        // Turn is appended as [w] or [b]
        function boardToString() {
            // Check if starting position
            if (game.fen() === 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1') {
                return 'start[w]';
            }

            var board = game.board();
            var output = '';

            // Iterate from rank 8 (top) to rank 1 (bottom)
            // Note: board[0] is rank 1, board[7] is rank 8
            for (var rank = 7; rank >= 0; rank--) {
                var emptyCount = 0;
                for (var file = 0; file < 8; file++) {
                    var square = board[7 - rank][file];
                    if (square === null) {
                        emptyCount++;
                    } else {
                        // Output any accumulated empty squares
                        if (emptyCount > 0) {
                            output += emptyCount;
                            emptyCount = 0;
                        }
                        output += PIECE_MAP_ENCODE[square.color][square.type];
                    }
                }
                // Output any remaining empty squares at end of rank
                if (emptyCount > 0) {
                    output += emptyCount;
                }
            }

            // Append turn information
            output += '[' + game.turn() + ']';

            return output;
        }

        // Validate state string format
        function validateState(state) {
            if (!state || typeof state !== 'string') {
                return {valid: false, error: 'State must be a non-empty string'};
            }

            // Check for start shortcut
            if (state === 'start[w]') {
                return {valid: true};
            }

            // Must end with [w] or [b]
            if (!state.match(/\[([wb])\]$/)) {
                return {valid: false, error: 'State must end with [w] or [b]'};
            }

            // Remove turn suffix for content validation
            var content = state.replace(/\[[wb]\]$/, '');

            // Must not be empty after removing turn
            if (content.length === 0) {
                return {valid: false, error: 'State content is empty'};
            }

            // Valid characters: A-L (pieces), 1-9 (empty squares)
            if (!content.match(/^[A-L1-9]+$/)) {
                return {valid: false, error: 'State contains invalid characters (must be A-L or 1-9)'};
            }

            // Validate piece counts don't exceed reasonable limits
            // Count total squares represented
            var squareCount = 0;
            for (var i = 0; i < content.length; i++) {
                var char = content[i];
                if (char >= '1' && char <= '9') {
                    squareCount += parseInt(char);
                } else {
                    squareCount += 1;
                }
            }

            // Chess board has 64 squares
            if (squareCount !== 64) {
                return {valid: false, error: 'State represents ' + squareCount + ' squares, expected 64'};
            }

            return {valid: true};
        }

        // Convert state string back to board position
        function stateToBoard(state) {
            // Validate first
            var validation = validateState(state);
            if (!validation.valid) {
                console.error('Invalid state:', validation.error, state);
                return null;
            }
            // Handle starting position
            if (state === 'start[w]') {
                return {
                    position: 'start',
                    turn: 'w'
                };
            }

            // Extract turn from state
            var turnMatch = state.match(/\[([wb])\]$/);
            if (!turnMatch) return null;
            var turn = turnMatch[1];

            // Remove turn suffix
            var boardString = state.replace(/\[[wb]\]$/, '');

            // Build position object for chessboard.js
            var position = {};
            var fileNames = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            var squareIndex = 0;  // 0-63, tracking position in encoded string

            for (var i = 0; i < boardString.length; i++) {
                var char = boardString[i];

                if (char >= '1' && char <= '9') {
                    // Empty squares
                    squareIndex += parseInt(char);
                } else if (PIECE_MAP_DECODE[char]) {
                    // Piece
                    var rank = 8 - Math.floor(squareIndex / 8);
                    var file = fileNames[squareIndex % 8];
                    position[file + rank] = PIECE_MAP_DECODE[char];
                    squareIndex++;
                }
            }

            return {
                position: position,
                turn: turn
            };
        }

        // Load a state onto the board
        function loadState(state, addToHistoryFlag) {
            var boardData = stateToBoard(state);
            if (!boardData) return;

            // Update board position first
            board.position(boardData.position);

            // Update game state - need to load via FEN
            if (state === 'start[w]') {
                game.reset();
            } else {
                // Build a FEN from the position
                var fen = buildFen(boardData.position, boardData.turn);
                game.load(fen);
            }

            // Update current board state
            currentBoardState = state;

            // Add to history if requested (e.g., when clicking nodes)
            if (addToHistoryFlag && !isNavigatingHistory) {
                addToHistory(state);
            }

            updateTurnLabel();
            drawGraph();
        }

        // Build FEN string from position and turn
        function buildFen(position, turn) {
            var fen = '';
            var fileNames = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];

            // Build board part of FEN
            for (var rank = 8; rank >= 1; rank--) {
                var emptyCount = 0;
                for (var fileIdx = 0; fileIdx < 8; fileIdx++) {
                    var square = fileNames[fileIdx] + rank;
                    var piece = position[square];

                    if (!piece) {
                        emptyCount++;
                    } else {
                        if (emptyCount > 0) {
                            fen += emptyCount;
                            emptyCount = 0;
                        }
                        // Convert piece format: wP -> P, bP -> p
                        var color = piece[0];
                        var type = piece[1];
                        fen += (color === 'w') ? type : type.toLowerCase();
                    }
                }
                if (emptyCount > 0) {
                    fen += emptyCount;
                }
                if (rank > 1) fen += '/';
            }

            // Add turn and dummy values for castling, en passant, etc.
            fen += ' ' + turn + ' KQkq - 0 1';
            return fen;
        }

        // Convert state to binary base64 format
        function stateToBinary(state) {
            // Handle start position
            if (state === 'start[w]') {
                return 'start[w]';
            }

            // Extract turn indicator
            var turnMatch = state.match(/\[([wb])\]$/);
            if (!turnMatch) {
                console.error('Invalid state format:', state);
                return state;
            }
            var turn = turnMatch[1];

            // Remove turn suffix
            var boardString = state.replace(/\[[wb]\]$/, '');

            // Decode board string to array of 64 square values
            var squares = [];
            for (var i = 0; i < boardString.length; i++) {
                var char = boardString[i];
                if (char >= '1' && char <= '9') {
                    // Empty squares
                    var count = parseInt(char);
                    for (var j = 0; j < count; j++) {
                        squares.push(0);
                    }
                } else if (PIECE_TO_NUM[char] !== undefined) {
                    squares.push(PIECE_TO_NUM[char]);
                }
            }

            // Pack 64 squares (4 bits each) into 32 bytes
            var bytes = [];
            for (var i = 0; i < 64; i += 2) {
                var high = squares[i] || 0;      // First square (high nibble)
                var low = squares[i + 1] || 0;   // Second square (low nibble)
                bytes.push((high << 4) | low);
            }

            // Convert bytes to base64
            var binaryString = '';
            for (var i = 0; i < bytes.length; i++) {
                binaryString += String.fromCharCode(bytes[i]);
            }
            var base64 = btoa(binaryString);

            return base64 + '[' + turn + ']';
        }

        // Convert binary base64 format back to regular state format
        function binaryToState(binaryState) {
            // Handle start position
            if (binaryState === 'start[w]') {
                return 'start[w]';
            }

            // Extract turn indicator
            var turnMatch = binaryState.match(/\[([wb])\]$/);
            if (!turnMatch) {
                console.error('Invalid binary state format:', binaryState);
                return binaryState;
            }
            var turn = turnMatch[1];

            // Remove turn suffix
            var base64 = binaryState.replace(/\[[wb]\]$/, '');

            // Decode base64 to bytes
            var binaryString = atob(base64);
            var bytes = [];
            for (var i = 0; i < binaryString.length; i++) {
                bytes.push(binaryString.charCodeAt(i));
            }

            // Unpack bytes to 64 square values (4 bits each)
            var squares = [];
            for (var i = 0; i < bytes.length; i++) {
                var byte = bytes[i];
                var high = (byte >> 4) & 0x0F;  // High nibble
                var low = byte & 0x0F;          // Low nibble
                squares.push(high);
                squares.push(low);
            }

            // Encode squares with run-length encoding for empty squares
            var output = '';
            var emptyCount = 0;

            function flushEmptyCount() {
                while (emptyCount > 0) {
                    if (emptyCount >= 9) {
                        output += '9';
                        emptyCount -= 9;
                    } else {
                        output += emptyCount;
                        emptyCount = 0;
                    }
                }
            }

            for (var i = 0; i < squares.length; i++) {
                var value = squares[i];
                if (value === 0) {
                    emptyCount++;
                } else {
                    flushEmptyCount();
                    output += NUM_TO_PIECE[value];
                }
            }
            flushEmptyCount();

            return output + '[' + turn + ']';
        }

        // Export all transitions to file (built from graph data)
        function exportAllStates() {
            if (graphEdges.length === 0) {
                alert('No transitions to export!');
                return;
            }

            // Prompt for filename
            var filename = prompt('Enter filename:', 'chess-openings.txt');
            if (!filename) return; // User cancelled

            // Ensure .txt extension
            if (!filename.endsWith('.txt')) {
                filename += '.txt';
            }

            // Build transitions from graph edges (using binary format)
            var transitions = graphEdges.map(function(edge) {
                var fromState = stateToBinary(graphNodes[edge.from]);
                var toState = stateToBinary(graphNodes[edge.to]);
                var transition = fromState + ' -> ' + toState;
                if (edge.annotation && edge.annotation.length > 0) {
                    transition += ': ' + edge.annotation;
                }
                return transition;
            });

            // Add version header for v2.0 (binary format)
            var content = 'v2.0\n' + transitions.join('\n');
            var blob = new Blob([content], { type: 'text/plain' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Export opening tree to PGN format
        function exportToPGN() {
            if (graphNodes.length <= 1) {
                alert('No moves to export!');
                return;
            }

            // Prompt for filename
            var filename = prompt('Enter filename:', 'opening-repertoire.pgn');
            if (!filename) return; // User cancelled

            // Ensure .pgn extension
            if (!filename.endsWith('.pgn')) {
                filename += '.pgn';
            }

            // Build PGN content
            var pgn = '[Event "Opening Repertoire"]\n';
            pgn += '[Site "Chess Opening Practice Tool"]\n';
            pgn += '[Date "' + new Date().toISOString().split('T')[0].replace(/-/g, '.') + '"]\n';
            pgn += '[White "Repertoire"]\n';
            pgn += '[Black "Repertoire"]\n';
            pgn += '[Result "*"]\n\n';

            // Generate move text with variations
            var moveText = generatePGNMoveText();
            pgn += moveText + ' *\n';

            // Download file
            var blob = new Blob([pgn], { type: 'text/plain' });
            var url = URL.createObjectURL(blob);
            var a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Generate PGN move text with variations
        function generatePGNMoveText() {
            var startIndex = stateToIndex.get('start[w]');
            if (startIndex === undefined) return '';

            var visited = new Set();
            var output = [];

            // Recursive function to traverse tree and build move text
            function traverseNode(nodeIndex, moveNumber, isWhiteTurn, depth) {
                if (visited.has(nodeIndex)) return;
                visited.add(nodeIndex);

                var state = graphNodes[nodeIndex];
                var children = [];

                // Find all children of this node
                graphEdges.forEach(function(edge) {
                    if (edge.from === nodeIndex) {
                        children.push(edge.to);
                    }
                });

                // Process each child
                for (var i = 0; i < children.length; i++) {
                    var childIndex = children[i];
                    var childState = graphNodes[childIndex];
                    var move = getMoveNotation(state, childState);

                    if (i === 0) {
                        // Main line
                        if (isWhiteTurn) {
                            output.push(moveNumber + '. ' + move);
                        } else {
                            if (output.length === 0 || output[output.length - 1].includes('...')) {
                                output.push(moveNumber + '... ' + move);
                            } else {
                                output.push(move);
                            }
                        }

                        // Continue main line
                        traverseNode(childIndex, isWhiteTurn ? moveNumber : moveNumber + 1, !isWhiteTurn, depth);
                    } else {
                        // Variation
                        var variation = [];
                        var savedOutput = output.slice();

                        output = variation;
                        if (isWhiteTurn) {
                            output.push(moveNumber + '. ' + move);
                        } else {
                            output.push(moveNumber + '... ' + move);
                        }
                        traverseNode(childIndex, isWhiteTurn ? moveNumber : moveNumber + 1, !isWhiteTurn, depth + 1);

                        // Add variation to main line
                        output = savedOutput;
                        output.push('(' + variation.join(' ') + ')');
                    }
                }
            }

            traverseNode(startIndex, 1, true, 0);
            return output.join(' ');
        }

        // Load pre-computed positions from JSON file
        function loadPositionsFromFile(fileContent, filename) {
            try {
                var positions = JSON.parse(fileContent);

                // Validate format
                if (typeof positions !== 'object') {
                    alert('Invalid positions file format');
                    return;
                }

                // Store positions
                precomputedPositions = positions;

                // Update label
                var label = document.getElementById('loadedFileLabel');
                var currentText = label.textContent;
                if (currentText) {
                    label.textContent = currentText + ' + Positions: ' + filename;
                } else {
                    label.textContent = 'Positions: ' + filename;
                }

                console.log('Loaded pre-computed positions for', Object.keys(positions).length, 'nodes');

                // Redraw graph with new positions
                drawGraph();
            } catch (e) {
                alert('Error loading positions file: ' + e.message);
                console.error('Position load error:', e);
            }
        }

        // Clear pre-computed positions
        function clearPositions() {
            precomputedPositions = null;
            console.log('Cleared pre-computed positions, reverting to Dagre layout');
        }

        // Load routes from file
        function loadRoutesFromFile(fileContent, filename) {
            // Clear existing graph data
            graphNodes = [];
            graphEdges = [];
            stateToIndex.clear();

            // Clear pre-computed positions when loading new routes
            precomputedPositions = null;

            // Parse the file line by line
            var lines = fileContent.split('\n');

            // First line must be version header
            if (lines.length === 0 || !lines[0].trim().match(/^v\d+\.\d+$/)) {
                alert('Invalid file format: Missing version header. Expected first line to be "v2.0" or higher.');
                return;
            }

            var version = lines[0].trim();

            // Only support v2.0 and higher
            if (version !== 'v2.0') {
                alert('Unsupported file version: ' + version + '. This tool only supports v2.0 format.');
                return;
            }

            // Parse transitions (v2.0 format with binary base64 encoding)
            var invalidCount = 0;
            for (var i = 1; i < lines.length; i++) {
                var line = lines[i].trim();
                if (line.length === 0) continue;

                // Parse transition: "binaryState1 -> binaryState2" or "binaryState1 -> binaryState2: annotation"
                var arrowSplit = line.split('->');
                if (arrowSplit.length === 2) {
                    var fromBinary = arrowSplit[0].trim();
                    var rightSide = arrowSplit[1];  // Don't trim yet

                    // Check if there's an annotation (indicated by ':')
                    var colonIndex = rightSide.indexOf(':');
                    var toBinary, annotation;

                    if (colonIndex !== -1) {
                        toBinary = rightSide.substring(0, colonIndex).trim();
                        annotation = rightSide.substring(colonIndex + 1).trim();
                    } else {
                        toBinary = rightSide.trim();
                        annotation = '';
                    }

                    // Convert binary states to regular format
                    var fromState = binaryToState(fromBinary);
                    var toState = binaryToState(toBinary);

                    // Validate both states
                    var fromValid = validateState(fromState);
                    var toValid = validateState(toState);

                    if (fromValid.valid && toValid.valid) {
                        addEdgeToGraph(fromState, toState, annotation);
                    } else {
                        invalidCount++;
                        console.warn('Skipping invalid transition on line ' + (i + 1) + ':',
                            !fromValid.valid ? fromValid.error : toValid.error);
                    }
                } else {
                    invalidCount++;
                    console.warn('Skipping malformed transition on line ' + (i + 1) + ':', line);
                }
            }

            // Warn user if some transitions were skipped
            if (invalidCount > 0) {
                alert('Warning: ' + invalidCount + ' invalid transition(s) were skipped. Check console for details.');
            }

            // Update loaded file label
            if (filename) {
                var label = 'Loaded: ' + filename;
                if (version) {
                    label += ' (' + version + ')';
                }
                document.getElementById('loadedFileLabel').textContent = label;
            }

            // Reset board to starting position
            game.reset();
            board.position('start');
            currentBoardState = 'start[w]';

            // Reset history
            moveHistory = ['start[w]'];
            historyIndex = 0;

            updateTurnLabel();
            updateHistoryButtons();
            drawGraph();
        }

        // Undo - go back in history
        function undo() {
            if (historyIndex <= 0) return;

            isNavigatingHistory = true;
            historyIndex--;

            // Remove the future from the graph
            removeFutureFromGraph();

            var state = moveHistory[historyIndex];
            loadState(state, false);
            updateHistoryButtons();
            isNavigatingHistory = false;
        }

        // Redo - go forward in history
        function redo() {
            if (historyIndex >= moveHistory.length - 1) return;

            isNavigatingHistory = true;
            historyIndex++;

            // Re-add the edge that we're redoing
            if (historyIndex > 0) {
                var fromState = moveHistory[historyIndex - 1];
                var toState = moveHistory[historyIndex];
                addEdgeToGraph(fromState, toState);
            }

            var state = moveHistory[historyIndex];
            loadState(state, false);
            updateHistoryButtons();
            isNavigatingHistory = false;
        }

        // Reset the board to starting position
        function createNewRoute() {
            game.reset();
            board.position('start');
            currentBoardState = 'start[w]';

            // Reset history
            moveHistory = ['start[w]'];
            historyIndex = 0;

            updateTurnLabel();
            updateHistoryButtons();
            drawGraph();
        }

        // Reset board and completely clear the graph
        function resetBoardAndGraph() {
            game.reset();
            board.position('start');
            currentBoardState = 'start[w]';

            // Reset history
            moveHistory = ['start[w]'];
            historyIndex = 0;

            // Clear graph data and reinitialize with starting state
            graphNodes = ['start[w]'];
            graphEdges = [];
            stateToIndex.clear();
            stateToIndex.set('start[w]', 0);
            lastEdgeIndex = -1;

            // Clear annotation input
            document.getElementById('annotationInput').value = '';

            updateTurnLabel();
            updateHistoryButtons();
            drawGraph();
        }

        // Cycle through different layout configurations
        function cycleLayout() {
            currentLayoutIndex = (currentLayoutIndex + 1) % layoutConfigs.length;
            var config = layoutConfigs[currentLayoutIndex];
            console.log('Switched to layout:', config.name);
            drawGraph();
        }

        // Fit graph to view (scale and center to show all nodes)
        function fitView() {
            if (nodePositions.length === 0) {
                // No nodes, just reset to default
                transform.zoom = 1.0;
                transform.offsetX = 0;
                transform.offsetY = 0;
                drawGraph();
                return;
            }

            // Calculate bounding box of all nodes
            var minX = Infinity, maxX = -Infinity;
            var minY = Infinity, maxY = -Infinity;

            nodePositions.forEach(function(pos) {
                minX = Math.min(minX, pos.x - nodeRadius);
                maxX = Math.max(maxX, pos.x + nodeRadius);
                minY = Math.min(minY, pos.y - nodeRadius);
                maxY = Math.max(maxY, pos.y + nodeRadius);
            });

            // Add padding
            var padding = 50;
            minX -= padding;
            maxX += padding;
            minY -= padding;
            maxY += padding;

            // Calculate required zoom to fit
            var graphWidth = maxX - minX;
            var graphHeight = maxY - minY;
            var zoomX = canvas.width / graphWidth;
            var zoomY = canvas.height / graphHeight;
            var zoom = Math.min(zoomX, zoomY);

            // Clamp zoom to reasonable range
            zoom = Math.max(0.1, Math.min(5, zoom));

            // Calculate center point of graph
            var graphCenterX = (minX + maxX) / 2;
            var graphCenterY = (minY + maxY) / 2;

            // Calculate offset to center the graph in the canvas
            var offsetX = canvas.width / 2 - graphCenterX * zoom;
            var offsetY = canvas.height / 2 - graphCenterY * zoom;

            // Apply transform
            transform.zoom = zoom;
            transform.offsetX = offsetX;
            transform.offsetY = offsetY;

            drawGraph();
        }

        // Update annotation input to show the annotation from the last edge
        function updateAnnotationInput() {
            var input = document.getElementById('annotationInput');

            if (lastEdgeIndex !== -1 && lastEdgeIndex < graphEdges.length) {
                input.value = graphEdges[lastEdgeIndex].annotation || '';
            } else {
                input.value = '';
            }
        }

        // Save annotation for the last move
        function saveAnnotation() {
            var input = document.getElementById('annotationInput');
            var text = input.value.trim();

            if (!text) {
                alert('Please enter an annotation first.');
                return;
            }

            if (lastEdgeIndex === -1 || lastEdgeIndex >= graphEdges.length) {
                alert('No move to annotate. Make a move first.');
                return;
            }

            // Strip out returns and quotes
            text = text.replace(/[\r\n]/g, ' ');  // Replace returns with spaces
            text = text.replace(/["']/g, '');      // Remove quotes

            // Save annotation to the last edge
            graphEdges[lastEdgeIndex].annotation = text;

            // Optionally redraw graph (in case we show annotations on nodes)
            drawGraph();
        }

        // Attach button handlers
        document.getElementById('exportBtn').addEventListener('click', exportAllStates);
        document.getElementById('exportPgnBtn').addEventListener('click', exportToPGN);
        document.getElementById('cycleLayoutBtn').addEventListener('click', cycleLayout);
        document.getElementById('fitViewBtn').addEventListener('click', fitView);
        document.getElementById('newRouteBtn').addEventListener('click', createNewRoute);
        document.getElementById('resetAllBtn').addEventListener('click', resetBoardAndGraph);
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);
        document.getElementById('saveAnnotationBtn').addEventListener('click', saveAnnotation);

        // Load button triggers file input
        document.getElementById('loadBtn').addEventListener('click', function() {
            document.getElementById('fileInput').click();
        });

        // Handle file selection
        document.getElementById('fileInput').addEventListener('change', function(event) {
            var file = event.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function(e) {
                    loadRoutesFromFile(e.target.result, file.name);
                };
                reader.readAsText(file);
            }
            // Reset the input so the same file can be loaded again
            event.target.value = '';
        });

        // Load positions button triggers positions file input
        document.getElementById('loadPositionsBtn').addEventListener('click', function() {
            document.getElementById('positionsInput').click();
        });

        // Handle positions file selection
        document.getElementById('positionsInput').addEventListener('change', function(event) {
            var file = event.target.files[0];
            if (file) {
                var reader = new FileReader();
                reader.onload = function(e) {
                    loadPositionsFromFile(e.target.result, file.name);
                };
                reader.readAsText(file);
            }
            // Reset the input so the same file can be loaded again
            event.target.value = '';
        });

        // Canvas setup for tree graph
        var canvas = document.getElementById('graphCanvas');
        var ctx = canvas.getContext('2d');
        var nodePositions = [];  // Store node positions for click detection
        // Constants
        var nodeRadius = 15;
        var PIECE_MAP_ENCODE = {
            'w': {'p': 'A', 'n': 'B', 'b': 'C', 'r': 'D', 'q': 'E', 'k': 'F'},
            'b': {'p': 'G', 'n': 'H', 'b': 'I', 'r': 'J', 'q': 'K', 'k': 'L'}
        };
        var PIECE_MAP_DECODE = {
            'A': 'wP', 'B': 'wN', 'C': 'wB', 'D': 'wR', 'E': 'wQ', 'F': 'wK',
            'G': 'bP', 'H': 'bN', 'I': 'bB', 'J': 'bR', 'K': 'bQ', 'L': 'bK'
        };
        var PIECE_TO_NUM = {
            'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6,
            'G': 7, 'H': 8, 'I': 9, 'J': 10, 'K': 11, 'L': 12
        };
        var NUM_TO_PIECE = {
            1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E', 6: 'F',
            7: 'G', 8: 'H', 9: 'I', 10: 'J', 11: 'K', 12: 'L'
        };
        var NODE_COLORS = {
            WHITE_TO_MOVE: '#D3D3D3',
            BLACK_TO_MOVE: '#696969',
            CURRENT: '#4CAF50'
        };
        var hoveredNodeIndex = -1;  // Track which node is being hovered

        // Transform state for zoom/pan
        var transform = {
            zoom: 1.0,
            offsetX: 0,
            offsetY: 0
        };

        // Layout configurations to cycle through
        var layoutConfigs = [
            { name: 'Network Simplex + DL', ranker: 'network-simplex', align: 'DL' },
            { name: 'Network Simplex + UL', ranker: 'network-simplex', align: 'UL' },
            { name: 'Network Simplex + UR', ranker: 'network-simplex', align: 'UR' },
            { name: 'Network Simplex + DR', ranker: 'network-simplex', align: 'DR' },
            { name: 'Tight Tree + DL', ranker: 'tight-tree', align: 'DL' },
            { name: 'Tight Tree + UL', ranker: 'tight-tree', align: 'UL' },
            { name: 'Tight Tree + UR', ranker: 'tight-tree', align: 'UR' },
            { name: 'Tight Tree + DR', ranker: 'tight-tree', align: 'DR' },
            { name: 'Longest Path + DL', ranker: 'longest-path', align: 'DL' },
            { name: 'Longest Path + UL', ranker: 'longest-path', align: 'UL' },
            { name: 'Longest Path + UR', ranker: 'longest-path', align: 'UR' },
            { name: 'Longest Path + DR', ranker: 'longest-path', align: 'DR' }
        ];
        var currentLayoutIndex = 0;

        // Set canvas size to match display size
        function resizeCanvas() {
            var rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            drawGraph();
        }

        // Calculate node positions using Dagre layout algorithm
        function calculateNodePositions() {
            if (graphNodes.length === 0) return [];

            // If we have pre-computed positions, use those
            if (precomputedPositions) {
                console.log('Using pre-computed positions from JSON file');
                var positions = [];
                for (var i = 0; i < graphNodes.length; i++) {
                    var state = graphNodes[i];
                    if (precomputedPositions[state]) {
                        positions.push({
                            x: precomputedPositions[state].x,
                            y: precomputedPositions[state].y
                        });
                    } else {
                        // Fallback for missing nodes
                        console.warn('No position found for state:', state);
                        positions.push({x: canvas.width / 2, y: 50 + i * 80});
                    }
                }
                return positions;
            }

            // Check if Dagre is available
            if (typeof dagre === 'undefined') {
                console.error('Dagre library not loaded! Falling back to simple layout.');
                return fallbackLayout();
            }

            // Create a new directed graph
            var g = new dagre.graphlib.Graph();

            // Get current layout configuration
            var config = layoutConfigs[currentLayoutIndex];

            // Set graph properties for layout with current configuration
            g.setGraph({
                rankdir: 'TB',      // Top to bottom
                align: config.align,
                nodesep: 60,        // Horizontal spacing between nodes (increased)
                edgesep: 10,        // Spacing between edges
                ranksep: 100,       // Vertical spacing between ranks (increased)
                marginx: 50,        // Horizontal margin
                marginy: 50,        // Vertical margin
                ranker: config.ranker
            });

            // Set default edge label
            g.setDefaultEdgeLabel(function() { return {}; });

            // Add nodes to the graph
            for (var i = 0; i < graphNodes.length; i++) {
                g.setNode(i.toString(), {
                    width: nodeRadius * 2,
                    height: nodeRadius * 2
                });
            }

            // Add edges to the graph
            graphEdges.forEach(function(edge) {
                g.setEdge(edge.from.toString(), edge.to.toString());
            });

            // Compute the layout
            try {
                dagre.layout(g);
                console.log('Dagre layout computed successfully for', graphNodes.length, 'nodes using:', config.name);
            } catch (e) {
                console.error('Dagre layout failed:', e);
                return fallbackLayout();
            }

            // Extract positions from Dagre's layout
            var positions = [];
            for (var i = 0; i < graphNodes.length; i++) {
                var node = g.node(i.toString());
                if (node) {
                    positions.push({
                        x: node.x,
                        y: node.y
                    });
                } else {
                    // Fallback for orphaned nodes
                    positions.push({x: canvas.width / 2, y: 50});
                }
            }

            return positions;
        }

        // Fallback layout if Dagre is not available
        function fallbackLayout() {
            var positions = [];
            var nodeDepth = new Array(graphNodes.length).fill(-1);
            var nodeCounts = {};

            // BFS to calculate depths
            var queue = [];
            var startIndex = stateToIndex.get('start[w]');
            if (startIndex !== undefined) {
                queue.push(startIndex);
                nodeDepth[startIndex] = 0;
            }

            while (queue.length > 0) {
                var current = queue.shift();
                var depth = nodeDepth[current];
                nodeCounts[depth] = (nodeCounts[depth] || 0) + 1;

                graphEdges.forEach(function(edge) {
                    if (edge.from === current && nodeDepth[edge.to] === -1) {
                        nodeDepth[edge.to] = depth + 1;
                        queue.push(edge.to);
                    }
                });
            }

            // Calculate positions
            var levelWidth = {};
            var verticalSpacing = 80;
            var horizontalSpacing = 60;

            for (var i = 0; i < graphNodes.length; i++) {
                var depth = nodeDepth[i];
                if (depth === -1) depth = 0;

                var nodesAtDepth = nodeCounts[depth] || 1;
                var currentCount = levelWidth[depth] || 0;
                levelWidth[depth] = currentCount + 1;

                var x = canvas.width / 2 + (currentCount - (nodesAtDepth - 1) / 2) * horizontalSpacing;
                var y = 50 + depth * verticalSpacing;

                positions.push({x: x, y: y});
            }

            return positions;
        }

        // Find the parent edges for a given node
        function getParentEdges(nodeIndex) {
            var parents = [];
            graphEdges.forEach(function(edge) {
                if (edge.to === nodeIndex) {
                    parents.push(edge);
                }
            });
            return parents;
        }

        // Calculate the move that was made between two states
        function getMoveNotation(fromState, toState) {
            // Simple approach: find destination square(s) only
            var fromData = stateToBoard(fromState);
            var toData = stateToBoard(toState);

            if (!fromData || !toData) return '?';

            var fromPos = fromData.position === 'start' ? getStartPosition() : fromData.position;
            var toPos = toData.position;

            // Find only destination squares (squares that now have a piece)
            var destSquares = [];
            for (var square in toPos) {
                // Only include if there's a piece here now and it's different from before
                if (toPos[square] && toPos[square] !== fromPos[square]) {
                    destSquares.push(square);
                }
            }

            // Return the destination squares joined
            if (destSquares.length > 0) {
                destSquares.sort();
                return destSquares.join(', ');
            }

            return '?';
        }

        function getStartPosition() {
            return {
                'a1': 'wR', 'b1': 'wN', 'c1': 'wB', 'd1': 'wQ', 'e1': 'wK', 'f1': 'wB', 'g1': 'wN', 'h1': 'wR',
                'a2': 'wP', 'b2': 'wP', 'c2': 'wP', 'd2': 'wP', 'e2': 'wP', 'f2': 'wP', 'g2': 'wP', 'h2': 'wP',
                'a7': 'bP', 'b7': 'bP', 'c7': 'bP', 'd7': 'bP', 'e7': 'bP', 'f7': 'bP', 'g7': 'bP', 'h7': 'bP',
                'a8': 'bR', 'b8': 'bN', 'c8': 'bB', 'd8': 'bQ', 'e8': 'bK', 'f8': 'bB', 'g8': 'bN', 'h8': 'bR'
            };
        }

        // Draw the graph
        function drawGraph() {
            // Clear and reset transform
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (graphNodes.length === 0) return;

            // Apply current transform (zoom and pan)
            ctx.setTransform(transform.zoom, 0, 0, transform.zoom, transform.offsetX, transform.offsetY);

            nodePositions = calculateNodePositions();

            // Draw edges first with straight lines
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            graphEdges.forEach(function(edge) {
                var fromPos = nodePositions[edge.from];
                var toPos = nodePositions[edge.to];

                ctx.beginPath();
                ctx.moveTo(fromPos.x, fromPos.y);
                ctx.lineTo(toPos.x, toPos.y);
                ctx.stroke();
            });

            // Draw nodes
            for (var i = 0; i < graphNodes.length; i++) {
                var pos = nodePositions[i];
                var state = graphNodes[i];

                // Determine color - green for current state, otherwise grey based on turn
                if (state === currentBoardState) {
                    ctx.fillStyle = NODE_COLORS.CURRENT;
                } else {
                    var isWhiteTurn = state.indexOf('[w]') !== -1;
                    ctx.fillStyle = isWhiteTurn ? NODE_COLORS.WHITE_TO_MOVE : NODE_COLORS.BLACK_TO_MOVE;
                }

                // Draw circle
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, nodeRadius, 0, 2 * Math.PI);
                ctx.fill();

                // Draw border
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw label only for starting state
                if (state === 'start[w]') {
                    ctx.fillStyle = '#000';
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('start', pos.x, pos.y + nodeRadius + 12);
                }

                // Draw square location tooltip for hovered node
                if (i === hoveredNodeIndex && state !== 'start[w]') {
                    var parentEdges = getParentEdges(i);
                    if (parentEdges.length > 0) {
                        // Get first parent (for transpositions, show first path)
                        var parentEdge = parentEdges[0];
                        var parentState = graphNodes[parentEdge.from];
                        var moveNotation = getMoveNotation(parentState, state);

                        // Calculate tooltip dimensions
                        ctx.font = 'bold 14px Arial';
                        ctx.textAlign = 'center';
                        var moveWidth = ctx.measureText(moveNotation).width;

                        var padding = 8;
                        var tooltipX = pos.x;
                        var tooltipY = pos.y - nodeRadius - 20;
                        var tooltipHeight = 20;

                        // Draw tooltip background
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(tooltipX - moveWidth / 2 - padding, tooltipY - tooltipHeight / 2 - 2, moveWidth + padding * 2, tooltipHeight);

                        // Draw move notation
                        ctx.font = 'bold 14px Arial';
                        ctx.fillStyle = '#fff';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(moveNotation, tooltipX, tooltipY);
                    }
                }
            }
        }

        // Convert screen coordinates to graph coordinates
        function screenToGraph(screenX, screenY) {
            return {
                x: (screenX - transform.offsetX) / transform.zoom,
                y: (screenY - transform.offsetY) / transform.zoom
            };
        }

        // Handle canvas clicks
        canvas.addEventListener('click', function(event) {
            var rect = canvas.getBoundingClientRect();
            var screenX = event.clientX - rect.left;
            var screenY = event.clientY - rect.top;

            // Convert to graph coordinates
            var graphCoords = screenToGraph(screenX, screenY);

            // Check if click is on any node
            for (var i = 0; i < nodePositions.length; i++) {
                var pos = nodePositions[i];
                var distance = Math.sqrt(Math.pow(graphCoords.x - pos.x, 2) + Math.pow(graphCoords.y - pos.y, 2));

                if (distance <= nodeRadius) {
                    // Node clicked - load its state and add to history
                    loadState(graphNodes[i], true);
                    break;
                }
            }
        });

        // Handle mouse wheel for zoom
        canvas.addEventListener('wheel', function(event) {
            event.preventDefault();

            var rect = canvas.getBoundingClientRect();
            var mouseX = event.clientX - rect.left;
            var mouseY = event.clientY - rect.top;

            // Zoom factor
            var zoomFactor = event.deltaY < 0 ? 1.1 : 0.9;
            var newZoom = transform.zoom * zoomFactor;

            // Limit zoom range
            newZoom = Math.max(0.1, Math.min(5, newZoom));

            // Zoom toward mouse position
            transform.offsetX = mouseX - (mouseX - transform.offsetX) * (newZoom / transform.zoom);
            transform.offsetY = mouseY - (mouseY - transform.offsetY) * (newZoom / transform.zoom);
            transform.zoom = newZoom;

            drawGraph();
        });

        // Handle mouse drag for pan
        var isPanning = false;
        var panStart = {x: 0, y: 0};

        canvas.addEventListener('mousedown', function(event) {
            if (event.button === 0) {  // Left click
                isPanning = true;
                panStart.x = event.clientX - transform.offsetX;
                panStart.y = event.clientY - transform.offsetY;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mousemove', function(event) {
            var rect = canvas.getBoundingClientRect();
            var screenX = event.clientX - rect.left;
            var screenY = event.clientY - rect.top;

            if (isPanning) {
                transform.offsetX = event.clientX - panStart.x;
                transform.offsetY = event.clientY - panStart.y;
                drawGraph();
            } else {
                // Check if hovering over a node
                var graphCoords = screenToGraph(screenX, screenY);
                var newHoveredIndex = -1;

                for (var i = 0; i < nodePositions.length; i++) {
                    var pos = nodePositions[i];
                    var distance = Math.sqrt(Math.pow(graphCoords.x - pos.x, 2) + Math.pow(graphCoords.y - pos.y, 2));

                    if (distance <= nodeRadius) {
                        newHoveredIndex = i;
                        canvas.style.cursor = 'pointer';
                        break;
                    }
                }

                if (newHoveredIndex === -1 && hoveredNodeIndex !== -1) {
                    canvas.style.cursor = 'default';
                }

                // Only redraw if hover state changed
                if (newHoveredIndex !== hoveredNodeIndex) {
                    hoveredNodeIndex = newHoveredIndex;
                    drawGraph();
                }
            }
        });

        canvas.addEventListener('mouseup', function(event) {
            if (event.button === 0) {
                isPanning = false;
                canvas.style.cursor = 'default';
            }
        });

        canvas.addEventListener('mouseleave', function() {
            isPanning = false;
            canvas.style.cursor = 'default';
            if (hoveredNodeIndex !== -1) {
                hoveredNodeIndex = -1;
                drawGraph();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', function(event) {
            // Check if user is typing in an input field
            var target = event.target;
            if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
                return;
            }

            // Ctrl+Z or Cmd+Z: Undo
            if ((event.ctrlKey || event.metaKey) && event.key === 'z' && !event.shiftKey) {
                event.preventDefault();
                undo();
            }
            // Ctrl+Y or Ctrl+Shift+Z or Cmd+Shift+Z: Redo
            else if ((event.ctrlKey || event.metaKey) && (event.key === 'y' || (event.key === 'z' && event.shiftKey))) {
                event.preventDefault();
                redo();
            }
            // Left Arrow: Undo
            else if (event.key === 'ArrowLeft') {
                event.preventDefault();
                undo();
            }
            // Right Arrow: Redo
            else if (event.key === 'ArrowRight') {
                event.preventDefault();
                redo();
            }
        });

        // Initialize graph with starting position
        addNodeToGraph('start[w]');

        // Initialize canvas
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Initialize button states
        updateHistoryButtons();
    </script>

</body>
</html>